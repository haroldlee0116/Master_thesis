
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>nls_gncgs</title><meta name="generator" content="MATLAB 9.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2022-01-27"><meta name="DC.source" content="nls_gncgs.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><pre class="codeinput"><span class="keyword">function</span> [z,output] = nls_gncgs(F,dF,z0,varargin)
<span class="comment">%NLS_GNCGS Nonlinear least squares by Gauss-Newton with CG-Steihaug.</span>
<span class="comment">%   [z,output] = nls_gncgs(F,dF,z0) starts at z0 and attempts to find a</span>
<span class="comment">%   local minimizer of the real-valued function f(z), which is the</span>
<span class="comment">%   nonlinear least squares objective function f(z) := 0.5*(F(z)'*F(z)).</span>
<span class="comment">%   The input variable z may be a scalar, vector, matrix, tensor or even a</span>
<span class="comment">%   (nested) cell array of tensors and its contents may be real or complex.</span>
<span class="comment">%   This method may be applied in the following ways:</span>
<span class="comment">%</span>
<span class="comment">%   1. F is function of both z and conj(z).</span>
<span class="comment">%</span>
<span class="comment">%      Method 1: general medium-scale problems.</span>
<span class="comment">%      nls_gncgs(F,dF,z0) where F(z) returns a column vector of complex</span>
<span class="comment">%      residuals. Set dF equal to the string 'Jacobian-C' for automatic</span>
<span class="comment">%      numerical approximation of the complex Jacobian, or supply the</span>
<span class="comment">%      complex Jacobian manually with a structure dF containing:</span>
<span class="comment">%</span>
<span class="comment">%         dF.dzc     - The function dF.dzc(zk) should return the complex</span>
<span class="comment">%                      Jacobian [dF(zk)/d(z^T) dF(zk)/d(conj(z)^T)], which</span>
<span class="comment">%                      is defined as the matrix in which the m-th row is</span>
<span class="comment">%                      equal to [(dFm(zk)/dz); (dFm(zk)/d(conj(z)))]^T,</span>
<span class="comment">%                      where Fm is the m-th component of F.</span>
<span class="comment">%</span>
<span class="comment">%      Method 2: general large-scale problems.</span>
<span class="comment">%      nls_gncgs(F,dF,z0) where F(z) returns a column vector of complex</span>
<span class="comment">%      residuals and dF is a structure containing:</span>
<span class="comment">%</span>
<span class="comment">%         dF.dzx     - The function dF.dzx(zk,x,'notransp') should return</span>
<span class="comment">%                      the matrix-vector product [dF(zk)/d(z^T)]*x and</span>
<span class="comment">%                      dF.dzx(zk,x,'transp') should return the</span>
<span class="comment">%                      matrix-vector product [dF(zk)/d(z^T)]'*x.</span>
<span class="comment">%         dF.dconjzx - The function dF.dconjzx(zk,x,'notransp') should</span>
<span class="comment">%                      return the matrix-vector product</span>
<span class="comment">%                      [dF(zk)/d(conj(z)^T)]*x and</span>
<span class="comment">%                      dF.dconjzx(zk,x,'transp') should return the matrix-</span>
<span class="comment">%                      vector product [dF(zk)/d(conj(z)^T)]'*x.</span>
<span class="comment">%</span>
<span class="comment">%   2. F is function only of z.</span>
<span class="comment">%</span>
<span class="comment">%      Method 1: analytic medium-scale problems.</span>
<span class="comment">%      nls_gncgs(F,dF,z0) where F(z) returns a column vector of complex</span>
<span class="comment">%      residuals. Set dF equal to the string 'Jacobian' for automatic</span>
<span class="comment">%      numerical approximation of the Jacobian, respectively. Or, supply</span>
<span class="comment">%      the Jacobian manually with a structure dF containing:</span>
<span class="comment">%</span>
<span class="comment">%         dF.dz      - The function dF.dz(zk) should return the Jacobian</span>
<span class="comment">%                      dF(zk)/d(z^T), which is defined as the matrix in</span>
<span class="comment">%                      which the m-th row is equal to (dFm(zk)/dz)^T, where</span>
<span class="comment">%                      Fm is the m-th component of F.</span>
<span class="comment">%</span>
<span class="comment">%      Method 2: analytic large-scale problems.</span>
<span class="comment">%      nls_gncgs(F,dF,z0) where F(z) returns a column vector of complex</span>
<span class="comment">%      residuals and dF is a structure containing:</span>
<span class="comment">%</span>
<span class="comment">%         dF.dzx     - The function dF.dzx(zk,x,'notransp') should return</span>
<span class="comment">%                      the matrix-vector product [dF(zk)/d(z^T)]*x and</span>
<span class="comment">%                      dF.dzx(zk,x,'transp') should return the matrix-</span>
<span class="comment">%                      vector product [dF(zk)/d(z^T)]'*x.</span>
<span class="comment">%</span>
<span class="comment">%      Method 3: analytic problems in a modest number of variables z and</span>
<span class="comment">%                large number of residuals F(z).</span>
<span class="comment">%      nls_gncgs(f,dF,z0) where f(z) := 0.5*(F(z)'*F(z)) and dF is a</span>
<span class="comment">%      structure containing:</span>
<span class="comment">%</span>
<span class="comment">%         dF.JHF     - The function dF.JHF(zk) should return</span>
<span class="comment">%                      [dF(zk)/d(z^T)]'*F(zk), which is also equal to</span>
<span class="comment">%                      2*df(zk)/d(conj(z)) = 2*conj(df(zk)/d(z)) if z is</span>
<span class="comment">%                      complex, or equal to df(xk)/dx if it is real.</span>
<span class="comment">%         dF.JHJ     - The function dF.JHF(zk) should return the Gramian</span>
<span class="comment">%                      [dF(zk)/d(z^T)]'*[dF(zk)/d(z^T)].</span>
<span class="comment">%</span>
<span class="comment">%      Method 4: analytic problems in a large number of variables z and</span>
<span class="comment">%                large number of residuals F(z).</span>
<span class="comment">%      nls_gncgs(f,dF,z0) where f(z) := 0.5*(F(z)'*F(z)) and dF is a</span>
<span class="comment">%      structure containing:</span>
<span class="comment">%</span>
<span class="comment">%         dF.JHF     - The function dF.JHF(zk) should return</span>
<span class="comment">%                      [dF(zk)/d(z^T)]'*F(zk), which is also equal to</span>
<span class="comment">%                      2*df(zk)/d(conj(z)) = 2*conj(df(zk)/d(z)) if z is</span>
<span class="comment">%                      complex, or equal to df(xk)/dx if it is real.</span>
<span class="comment">%         dF.JHJx    - The function dF.JHF(zk,x) should return the matrix-</span>
<span class="comment">%                      vector product ([dF(zk)/d(z^T)]'*[dF(zk)/d(z^T)])*x.</span>
<span class="comment">%</span>
<span class="comment">%   The structure output returns additional information:</span>
<span class="comment">%</span>
<span class="comment">%      output.cgiterations - The number of CG iterations to solve the</span>
<span class="comment">%                            trust-region subproblem.</span>
<span class="comment">%      output.cgrelres     - The relative residual norm of the computed</span>
<span class="comment">%                            Steihaug step.</span>
<span class="comment">%      output.delta        - The trust region radius at every step attempt.</span>
<span class="comment">%      output.fval         - The value of the objective function f in every</span>
<span class="comment">%                            iteration.</span>
<span class="comment">%      output.info         - The circumstances under which the procedure</span>
<span class="comment">%                            terminated:</span>
<span class="comment">%                               1: Objective function tolerance reached.</span>
<span class="comment">%                               2: Step size tolerance reached.</span>
<span class="comment">%                               3: Maximum number of iterations reached.</span>
<span class="comment">%                               4: Absolute objective function tolerance</span>
<span class="comment">%                                  reached.</span>
<span class="comment">%      output.iterations   - The number of iterations.</span>
<span class="comment">%      output.relfval      - The difference in objective function value</span>
<span class="comment">%                            between every two successive iterates,</span>
<span class="comment">%                            relativeto its initial value.</span>
<span class="comment">%      output.relstep      - The step size relative to the norm of the</span>
<span class="comment">%                            current iterate in every iteration.</span>
<span class="comment">%      output.rho          - The trustworthiness at every step attempt.</span>
<span class="comment">%</span>
<span class="comment">%   nls_gncgs(F,dF,z0,options) may be used to set the following options:</span>
<span class="comment">%</span>
<span class="comment">%      options.CGMaxIter = 15 - The maximum number of CG iterations for</span>
<span class="comment">%                               solving the trust-region subproblem.</span>
<span class="comment">%      options.CGTol = 1e-6   - The tolerance for the CG method for solving</span>
<span class="comment">%                               the trust-region subproblem.</span>
<span class="comment">%      options.Delta =        - The initial trust region radius. If equal</span>
<span class="comment">%      0.3*max(1,norm(z0))      NaN, the initial radius will be equal to</span>
<span class="comment">%                               length of the first Gauss-Newton step.</span>
<span class="comment">%      options.Display = 1    - Displays the objective function value, its</span>
<span class="comment">%                               difference with the previous iterate</span>
<span class="comment">%                               relative to the first iterate and the</span>
<span class="comment">%                               relative step size each options.Display</span>
<span class="comment">%                               iterations. Set to 0 to disable.</span>
<span class="comment">%      options.MaxIter = 200  - The maximum number of iterations.</span>
<span class="comment">%      options.TolFun = 1e-12 - The tolerance for output.relfval. Note that</span>
<span class="comment">%                               because the objective function is a squared</span>
<span class="comment">%                               norm, TolFun can be as small as eps^2.</span>
<span class="comment">%      options.TolX = 1e-6    - The tolerance for output.relstep.</span>
<span class="comment">%      options.TolAbs = 0     - The tolerance for output.fval.</span>

<span class="comment">%   Authors: Laurent Sorber      (Laurent.Sorber@cs.kuleuven.be)</span>
<span class="comment">%            Nico Vervliet       (Nico.Vervliet@esat.kuleuven.be)</span>
<span class="comment">%            Marc Van Barel      (Marc.VanBarel@cs.kuleuven.be)</span>
<span class="comment">%            Lieven De Lathauwer (Lieven.DeLathauwer@kuleuven-kulak.be)</span>
<span class="comment">%</span>
<span class="comment">%   References:</span>
<span class="comment">%   [1] L. Sorber, M. Van Barel, L. De Lathauwer, "Unconstrained</span>
<span class="comment">%       optimization of real functions in complex variables", SIAM J. Opt.,</span>
<span class="comment">%       Vol. 22, No. 3, 2012, pp. 879-898.</span>
<span class="comment">%</span>
<span class="comment">% Version History:</span>
<span class="comment">% - 2016/02/18    NV    Added absolute tolerance and option parser</span>

<span class="comment">% Check the objective function f, derivative dF and first iterate z0.</span>
<span class="keyword">if</span> ~isa(F,<span class="string">'function_handle'</span>)
    error(<span class="string">'nls_gncgs:F'</span>,<span class="string">'The first argument must be a function.'</span>);
<span class="keyword">end</span>
<span class="keyword">if</span> ischar(dF)
    type = dF;
    <span class="keyword">if</span> strcmp(type,<span class="string">'Jacobian-C'</span>), fld = <span class="string">'dzc'</span>; <span class="keyword">else</span> fld = <span class="string">'dz'</span>; <span class="keyword">end</span>
    dF = struct(fld,@derivjac);
<span class="keyword">end</span>
<span class="keyword">if</span> ~isstruct(dF)
    error(<span class="string">'nls_gncgs:dF'</span>,<span class="string">'Second argument not valid.'</span>);
<span class="keyword">else</span>
    <span class="keyword">if</span> isfield(dF,<span class="string">'dzc'</span>)
        method = <span class="string">'F+dFdzc'</span>;
    <span class="keyword">elseif</span> isfield(dF,<span class="string">'dzx'</span>) &amp;&amp; isfield(dF,<span class="string">'dconjzx'</span>)
        method = <span class="string">'F+dFdzx+dFdconjzx'</span>;
    <span class="keyword">elseif</span> isfield(dF,<span class="string">'dz'</span>)
        method = <span class="string">'F+dFdz'</span>;
    <span class="keyword">elseif</span> isfield(dF,<span class="string">'dzx'</span>)
        method = <span class="string">'F+dFdzx'</span>;
    <span class="keyword">elseif</span> isfield(dF,<span class="string">'JHJ'</span>)  &amp;&amp; isfield(dF,<span class="string">'JHF'</span>)
        method = <span class="string">'f+JHJ+JHF'</span>;
        f = F;
    <span class="keyword">elseif</span> isfield(dF,<span class="string">'JHJx'</span>) &amp;&amp; isfield(dF,<span class="string">'JHF'</span>)
        method = <span class="string">'f+JHJx+JHF'</span>;
        f = F;
    <span class="keyword">else</span>
        error(<span class="string">'nls_gncgs:dF'</span>, <span class="keyword">...</span>
             [<span class="string">'The structure dF should supply [dF.dzc] or '</span> <span class="keyword">...</span>
              <span class="string">'[dF.dzx and dF.dconjzx] or [dF.dz] or [dF.dzx] or '</span> <span class="keyword">...</span>
              <span class="string">'[dF.JHJ and dF.JHF] or [dF.JHJx and dF.JHF].'</span>]);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% Evaluate the function value at z0.</span>
dim = structure(z0);
z = z0;
z0 = serialize(z0);
<span class="keyword">switch</span> method
    <span class="keyword">case</span> {<span class="string">'F+dFdzc'</span>,<span class="string">'F+dFdzx+dFdconjzx'</span>,<span class="string">'F+dFdz'</span>,<span class="string">'F+dFdzx'</span>}
        Fval = F(z); Fval = Fval(:);
        fval = 0.5*sum(Fval'*Fval);
    <span class="keyword">case</span> {<span class="string">'f+JHJ+JHF'</span>,<span class="string">'f+JHJx+JHF'</span>}
        fval = f(z);
<span class="keyword">end</span>

<span class="comment">% Numerical approximaton of complex derivatives.</span>
<span class="keyword">function</span> J = derivjac(zk)
    J = deriv(F,zk,Fval,type);
<span class="keyword">end</span>

<span class="comment">% In the case 'F+dFdzx+dFdconjzx', convert J*x and J'*x to the real domain,</span>
<span class="comment">% and compute J'*(J*x) in the real domain.</span>
<span class="keyword">function</span> y = JH_Jx(x)
    x = x(1:end/2)+x(end/2+1:end)*1i;
    dFdzx = dF.dzx(z,x,<span class="string">'notransp'</span>);
    dFdconjzconjx = dF.dconjzx(z,conj(x),<span class="string">'notransp'</span>);
    y = real(dFdzx)+real(dFdconjzconjx)+ <span class="keyword">...</span>
        (imag(dFdzx)+imag(dFdconjzconjx))*1i;
	dFdzx = dF.dzx(z,y,<span class="string">'transp'</span>);
    dFdconjzx = dF.dconjzx(z,y,<span class="string">'transp'</span>);
    y = [real(dFdzx)+real(dFdconjzx); <span class="keyword">...</span>
         imag(dFdzx)-imag(dFdconjzx)];
<span class="keyword">end</span>

<span class="comment">% In the case 'F+dFdzx', compute dFdz'*(dFdz*x).</span>
<span class="keyword">function</span> y = dFdzH_dFdzx(x)
    y = dF.dzx(z,dF.dzx(z,x,<span class="string">'notransp'</span>),<span class="string">'transp'</span>);
<span class="keyword">end</span>

<span class="comment">% In the case 'f+JHJx+JHF', compute JHJ*x.</span>
<span class="keyword">function</span> y = JHJx(x)
    y = dF.JHJx(z,x);
<span class="keyword">end</span>

<span class="comment">% Modify the preconditioner, if available.</span>
<span class="keyword">if</span> isfield(dF,<span class="string">'M'</span>) &amp;&amp; ~isempty(dF.M), dF.PC = @PC; <span class="keyword">else</span> dF.PC = []; <span class="keyword">end</span>
<span class="keyword">function</span> x = PC(b)
    x = dF.M(z,b);
<span class="keyword">end</span>

<span class="comment">% Check the options structure.</span>
p = inputParser;
p.addOptional(<span class="string">'CGMaxIter'</span>, 15);
p.addOptional(<span class="string">'CGTol'</span>, 1e-6);
p.addOptional(<span class="string">'Delta'</span>, 0.3*max(1,norm(z0)));
p.addOptional(<span class="string">'Display'</span>, 1);
p.addOptional(<span class="string">'MaxIter'</span>, 200);
p.addOptional(<span class="string">'TolFun'</span>, 1e-12);
p.addOptional(<span class="string">'TolX'</span>, 1e-6);
p.addOptional(<span class="string">'TolAbs'</span>, 0);
p.KeepUnmatched = true;
p.parse(varargin{:});
options = p.Results;

<span class="comment">% Gauss-Newton with dogleg trust region.</span>
output.cgiterations = [];
output.cgrelres = [];
output.delta = options.Delta;
output.fval = fval;
output.info = false;
output.iterations = 0;
output.relfval = [];
output.relstep = [];
output.rho = [];
<span class="keyword">while</span> ~output.info

    <span class="comment">% Compute first-order derivatives.</span>
    <span class="keyword">switch</span> method
        <span class="keyword">case</span> <span class="string">'F+dFdzc'</span>
            dFdzc = dF.dzc(z);
            dFdz = dFdzc(:,1:end/2);
            dFdconjz = dFdzc(:,end/2+1:end);
            J = [real(dFdz)+real(dFdconjz),imag(dFdconjz)-imag(dFdz); <span class="keyword">...</span>
                 imag(dFdz)+imag(dFdconjz),real(dFdz)-real(dFdconjz)];
            JHJ = J'*J;
            grad = dFdz'*Fval+dFdconjz.'*conj(Fval);
            grad = [real(grad);imag(grad)];
        <span class="keyword">case</span> <span class="string">'F+dFdzx+dFdconjzx'</span>
            grad = dF.dzx(z,Fval,<span class="string">'transp'</span>)+ <span class="keyword">...</span>
                   conj(dF.dconjzx(z,Fval,<span class="string">'transp'</span>));
            grad = [real(grad);imag(grad)];
        <span class="keyword">case</span> <span class="string">'F+dFdz'</span>
            dFdz = dF.dz(z);
            JHJ = dFdz'*dFdz;
            grad = dFdz'*Fval;
        <span class="keyword">case</span> <span class="string">'F+dFdzx'</span>
            grad = dF.dzx(z,Fval,<span class="string">'transp'</span>);
        <span class="keyword">case</span> <span class="string">'f+JHJ+JHF'</span>
            grad = serialize(dF.JHF(z));
            JHJ = dF.JHJ(z);
        <span class="keyword">case</span> <span class="string">'f+JHJx+JHF'</span>
            grad = serialize(dF.JHF(z));
    <span class="keyword">end</span>

    <span class="comment">% CG-Steihaug.</span>
    rho = -inf;
    <span class="keyword">while</span> rho &lt;= 0

        <span class="comment">% Compute the CG-Steihaug step p and estimate objective function</span>
        <span class="comment">% improvement.</span>
        delta = output.delta(end);
        <span class="keyword">switch</span> method
            <span class="keyword">case</span> <span class="string">'F+dFdzc'</span>
                [p,~,output.cgrelres(end+1),output.cgiterations(end+1)] <span class="keyword">...</span>
                    = pcgsh(JHJ,-grad,delta, <span class="keyword">...</span>
                            options.CGTol,options.CGMaxIter,dF.PC);
                p = p(1:end/2)+p(end/2+1:end)*1i;
                grad = grad(1:end/2)+grad(end/2+1:end)*1i;
                dfval = dFdz*p+dFdconjz*conj(p);
                dfval = -real(p'*grad)-0.5*(dfval'*dfval);
                grad = [real(grad);imag(grad)];
            <span class="keyword">case</span> <span class="string">'F+dFdzx+dFdconjzx'</span>
                [p,~,output.cgrelres(end+1),output.cgiterations(end+1)] <span class="keyword">...</span>
                    = pcgsh(@JH_Jx,-grad,delta, <span class="keyword">...</span>
                            options.CGTol,options.CGMaxIter+50,dF.PC);
                p = p(1:end/2)+p(end/2+1:end)*1i;
                grad = grad(1:end/2)+grad(end/2+1:end)*1i;
                dfval = dF.dzx(z,p,<span class="string">'notransp'</span>)+ <span class="keyword">...</span>
                        dF.dconjzx(z,conj(p),<span class="string">'notransp'</span>);
                dfval = -real(p'*grad)-0.5*(dfval'*dfval);
                grad = [real(grad);imag(grad)];
            <span class="keyword">case</span> <span class="string">'F+dFdz'</span>
                [p,~,output.cgrelres(end+1),output.cgiterations(end+1)] <span class="keyword">...</span>
                    = pcgsh(JHJ,-grad,delta, <span class="keyword">...</span>
                            options.CGTol,options.CGMaxIter,dF.PC);
                dfval = dFdz*p;
                dfval = -real(p'*grad)-0.5*(dfval'*dfval);
            <span class="keyword">case</span> <span class="string">'F+dFdzx'</span>
                [p,~,output.cgrelres(end+1),output.cgiterations(end+1)] <span class="keyword">...</span>
                    = pcgsh(@dFdzH_dFdzx,-grad,delta, <span class="keyword">...</span>
                            options.CGTol,options.CGMaxIter,dF.PC);
                dfval = dF.dzx(z,p,<span class="string">'notransp'</span>);
                dfval = -real(p'*grad)-0.5*(dfval'*dfval);
            <span class="keyword">case</span> <span class="string">'f+JHJ+JHF'</span>
                [p,~,output.cgrelres(end+1),output.cgiterations(end+1)] <span class="keyword">...</span>
                    = pcgsh(JHJ,-grad,delta, <span class="keyword">...</span>
                            options.CGTol,options.CGMaxIter,dF.PC);
                dfval = -real(p'*grad)-0.5*real(p'*JHJ*p);
            <span class="keyword">case</span> <span class="string">'f+JHJx+JHF'</span>
                [p,~,output.cgrelres(end+1),output.cgiterations(end+1)] <span class="keyword">...</span>
                    = pcgsh(@JHJx,-grad,delta, <span class="keyword">...</span>
                            options.CGTol,options.CGMaxIter,dF.PC);
                dfval = -real(p'*grad)-0.5*real(p'*dF.JHJx(z,p));
        <span class="keyword">end</span>
        <span class="keyword">if</span> isnan(output.delta(end))
            delta = max(1,norm(p));
            output.delta(end) = delta;
        <span class="keyword">end</span>

        <span class="comment">% Compute the trustworthiness rho.</span>
        <span class="keyword">if</span> dfval &gt; 0
            z1 = deserialize(z0+p,dim);
            <span class="keyword">switch</span> method
                <span class="keyword">case</span> {<span class="string">'F+dFdzc'</span>,<span class="string">'F+dFdzx+dFdconjzx'</span>,<span class="string">'F+dFdz'</span>,<span class="string">'F+dFdzx'</span>}
                    Fval = F(z1); Fval = Fval(:);
                    fval = 0.5*sum(Fval'*Fval);
                <span class="keyword">case</span> {<span class="string">'f+JHJ+JHF'</span>,<span class="string">'f+JHJx+JHF'</span>}
                    fval = f(z1);
            <span class="keyword">end</span>
            rho = (output.fval(end)-fval)/dfval;
            <span class="keyword">if</span> isnan(rho), rho = -inf; <span class="keyword">end</span>
            output.rho(end+1) = rho;
        <span class="keyword">end</span>

        <span class="comment">% Update trust region radius delta.</span>
        <span class="keyword">if</span> rho &gt; 0.5
            output.delta(end+1) = max(delta,2*norm(p));
        <span class="keyword">else</span>
            sigma = (1-0.25)/(1+exp(-14*(rho-0.25)))+0.25;
            output.delta(end+1) = sigma*delta;
        <span class="keyword">end</span>

        <span class="comment">% Check for convergence.</span>
        relstep = norm(p)/norm(z0); <span class="keyword">if</span> isnan(relstep), relstep = 0; <span class="keyword">end</span>
        <span class="keyword">if</span> rho &lt;= 0 &amp;&amp; relstep &lt;= options.TolX
            output.rho(end+1) = rho;
            fval = output.fval(end);
            z = deserialize(z0,dim);
            <span class="keyword">break</span>;
        <span class="keyword">end</span>

    <span class="keyword">end</span>

    <span class="comment">% Save current state.</span>
    <span class="keyword">if</span> rho &gt; 0
        z = z1;
        z0 = z0+p;
    <span class="keyword">end</span>

    <span class="comment">% Update the output structure.</span>
    output.fval(end+1) = fval;
    output.iterations = output.iterations+1;
    output.relfval(end+1) = <span class="keyword">...</span>
        abs(diff(output.fval(end:-1:end-1)))/abs(output.fval(1));
    output.relstep(end+1) = relstep;
    <span class="keyword">if</span> output.relfval(end) &lt;= options.TolFun, output.info = 1; <span class="keyword">end</span>
    <span class="keyword">if</span> output.relstep(end) &lt;= options.TolX, output.info = 2; <span class="keyword">end</span>
    <span class="keyword">if</span> output.iterations &gt;= options.MaxIter, output.info = 3; <span class="keyword">end</span>
    <span class="keyword">if</span> output.fval(end) &lt; options.TolAbs, output.info = 4; <span class="keyword">end</span>

    <span class="comment">% Display progress.</span>
    <span class="keyword">if</span> options.Display &gt; 0 &amp;&amp; (output.iterations == 1 || output.info || <span class="keyword">...</span>
       mod(output.iterations,options.Display) == 0)
        <span class="keyword">if</span> output.iterations == 1
            bold = <span class="string">'%s'</span>;
            [~,~,~,~,v] = regexp(version(<span class="string">'-release'</span>),<span class="string">'([0-9]+)([ab])'</span>);
            <span class="keyword">if</span> usejava(<span class="string">'Desktop'</span>) &amp;&amp; str2double(v{1}{1}) &gt; 2011 || <span class="keyword">...</span>
               (str2double(v{1}{1}) == 2011 &amp;&amp; strcmpi(v{1}{2},<span class="string">'b'</span>))
                bold = <span class="string">'&lt;strong&gt;%s&lt;/strong&gt;'</span>;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">if</span> output.iterations == 1 || <span class="keyword">...</span>
           mod(output.iterations,15*options.Display) == 0
            fprintf(<span class="string">'\n%7s%s'</span>,<span class="string">''</span>,sprintf(bold,<span class="string">'fval'</span>));
            fprintf(<span class="string">'%13s%s'</span>,<span class="string">''</span>,sprintf(bold,<span class="string">'relfval'</span>));
            fprintf(<span class="string">'%10s%s'</span>,<span class="string">''</span>,sprintf(bold,<span class="string">'relstep'</span>));
            fprintf(<span class="string">'%10s%s'</span>,<span class="string">''</span>,sprintf(bold,<span class="string">'delta'</span>));
            fprintf(<span class="string">'%8s%s'</span>,<span class="string">''</span>,sprintf(bold,<span class="string">'rho'</span>));
            fprintf(<span class="string">'\n%21s%9s = %4.e %6s = %4.e\n\n'</span>,<span class="string">'=1/2*norm(F)^2'</span>, <span class="keyword">...</span>
                    <span class="string">'TolFun'</span>,options.TolFun,<span class="string">'TolX'</span>,options.TolX);
        <span class="keyword">end</span>
        <span class="keyword">if</span> output.iterations == 1
            fprintf(<span class="string">'%4i: % 14.8e |\n'</span>,0,output.fval(1));
        <span class="keyword">end</span>
        fprintf(<span class="string">'%4i: % 14.8e | %14.8e | %14.8e | %10.4e | %10.4e\n'</span>, <span class="keyword">...</span>
                output.iterations,output.fval(end), <span class="keyword">...</span>
                output.relfval(end),output.relstep(end), <span class="keyword">...</span>
                output.delta(end),output.rho(end));
    <span class="keyword">end</span>

<span class="keyword">end</span>

<span class="comment">% Display termination message.</span>
<span class="keyword">if</span> options.Display &gt; 0
    ahref = <span class="string">'\n%s\n\n'</span>;
    x = round(linspace(0,output.iterations,min(500,output.iterations)));
    <span class="keyword">if</span> length(bold) &gt; 2
        ahref = sprintf([<span class="string">'\n&lt;a href="matlab:semilogy(%s,%s);'</span> <span class="keyword">...</span>
            <span class="string">'xlabel(''iteration'');legend(''fval'','</span> <span class="keyword">...</span>
            <span class="string">'''relfval'',''relstep'')"&gt;%%s&lt;/a&gt;\n\n'</span>],mat2str(x'), <span class="keyword">...</span>
            mat2str([output.fval(x+1)' [nan output.relfval(x(2:end))]' <span class="keyword">...</span>
                    [nan output.relstep(x(2:end))]'],3));
    <span class="keyword">end</span>
    <span class="keyword">switch</span> output.info
      <span class="keyword">case</span> 1, fprintf(ahref,<span class="string">'Objective function tolerance reached.'</span>);
      <span class="keyword">case</span> 2, fprintf(ahref,<span class="string">'Step size tolerance reached.'</span>);
      <span class="keyword">case</span> 3, fprintf(ahref,<span class="string">'Maximum number of iterations reached.'</span>);
      <span class="keyword">case</span> 4, fprintf(ahref,<span class="string">'Absolute objective function tolerance reached.'</span>);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">end</span>

<span class="keyword">function</span> [z,offset] = deserialize(z,dim,offset)
    <span class="keyword">if</span> iscell(dim)
        v = z;
        z = cell(size(dim));
        <span class="keyword">if</span> nargin &lt; 3, offset = 0; <span class="keyword">end</span>
        <span class="keyword">for</span> i = 1:numel(z)
            <span class="keyword">if</span> iscell(dim{i})
                [z{i},offset] = deserialize(v,dim{i},offset);
            <span class="keyword">else</span>
                n = prod(dim{i}(:));
                z{i} = reshape(v(offset+(1:n)),dim{i});
                offset = offset+n;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">elseif</span> ~isempty(dim)
        z = reshape(z,dim);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> z = serialize(z)
    <span class="keyword">if</span> iscell(z)
        <span class="keyword">for</span> i = find(cellfun(@iscell,z(:).'))
            z{i} = serialize(z{i});
        <span class="keyword">end</span>
        s = cellfun(@numel,z(:)); o = [0; cumsum(s)];
        c = z; z = zeros(o(end),1);
        <span class="keyword">for</span> i = 1:length(s), z(o(i)+(1:s(i))) = c{i}(:); <span class="keyword">end</span>
    <span class="keyword">else</span>
        z = z(:);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> dim = structure(z)
    <span class="keyword">if</span> iscell(z)
        dim = cellfun(@size,z,<span class="string">'UniformOutput'</span>,false);
        <span class="keyword">for</span> i = find(cellfun(@iscell,z(:).'))
            dim{i} = structure(z{i});
        <span class="keyword">end</span>
    <span class="keyword">else</span>
        dim = size(z);
        <span class="keyword">if</span> numel(z) == dim(1), dim = []; <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> [x,flag,relres,iter] = pcgsh(A,b,delta,tol,maxit,M)

<span class="comment">% Check the options.</span>
<span class="keyword">if</span> nargin &lt; 3, delta = nan; <span class="keyword">end</span>
<span class="keyword">if</span> nargin &lt; 4 || isempty(tol), tol = 1e-6; <span class="keyword">end</span>
<span class="keyword">if</span> nargin &lt; 5 || isempty(maxit), maxit = min(20,length(b)); <span class="keyword">end</span>
PC = nargin &gt; 5 &amp;&amp; (isa(M,<span class="string">'function_handle'</span>) || <span class="keyword">...</span>
     (isnumeric(M) &amp;&amp; all(size(M) == length(b))));

<span class="comment">% Initialize PCG-Steihaug.</span>
x = zeros(size(b));
r = -b;
<span class="keyword">if</span> PC
    <span class="keyword">if</span> isnumeric(M), y = M\r;
    <span class="keyword">else</span> y = M(r); <span class="keyword">end</span>
    d = -y;
    rr = r'*y;
<span class="keyword">else</span>
    d = -r;
    rr = r'*r;
<span class="keyword">end</span>
normb = sqrt(rr);
flag = 1;

<span class="comment">% PCG-Steihaug.</span>
<span class="keyword">for</span> iter = 1:maxit

    <span class="keyword">if</span> isnumeric(A), Ad = A*d;
    <span class="keyword">else</span> Ad = A(d); <span class="keyword">end</span>
    alpha = rr/(d'*Ad);

    x1 = x;
    x = x+alpha*d;

    <span class="comment">% Steihaug's stopping criterion. The case of directions of negative</span>
    <span class="comment">% curvature does not need to be handled for NLS.</span>
    <span class="keyword">if</span> ~isnan(delta) &amp;&amp; norm(x) &gt;= delta
        xx = x1'*x1;
        dd = d'*d;
        c = real(x1'*d);
        alpha = (delta^2-xx)/(c+sqrt(c^2+dd*(delta^2-xx)));
        x = x1+alpha*d;
        flag = 2;
    <span class="keyword">end</span>

    r = r+alpha*Ad;
    rr1 = rr;
    <span class="keyword">if</span> PC
        <span class="keyword">if</span> isnumeric(M), y = M\r;
        <span class="keyword">else</span> y = M(r); <span class="keyword">end</span>
        rr = r'*y;
    <span class="keyword">else</span>
        rr = r'*r;
    <span class="keyword">end</span>

    <span class="keyword">if</span> PC, relres = norm(r)/normb;
    <span class="keyword">else</span> relres = sqrt(rr)/normb; <span class="keyword">end</span>
    <span class="keyword">if</span> flag ~= 1, <span class="keyword">break</span>; <span class="keyword">end</span>
    <span class="keyword">if</span> relres &lt; tol, flag = 0; <span class="keyword">break</span>; <span class="keyword">end</span>

    beta = rr/rr1;
    <span class="keyword">if</span> PC, d = -y+beta*d;
    <span class="keyword">else</span> d = -r+beta*d; <span class="keyword">end</span>

<span class="keyword">end</span>

<span class="keyword">end</span>
</pre><pre class="codeoutput error">Not enough input arguments.

Error in nls_gncgs (line 143)
if ~isa(F,'function_handle')
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018a</a><br></p></div><!--
##### SOURCE BEGIN #####
function [z,output] = nls_gncgs(F,dF,z0,varargin)
%NLS_GNCGS Nonlinear least squares by Gauss-Newton with CG-Steihaug.
%   [z,output] = nls_gncgs(F,dF,z0) starts at z0 and attempts to find a
%   local minimizer of the real-valued function f(z), which is the
%   nonlinear least squares objective function f(z) := 0.5*(F(z)'*F(z)).
%   The input variable z may be a scalar, vector, matrix, tensor or even a
%   (nested) cell array of tensors and its contents may be real or complex.
%   This method may be applied in the following ways:
%
%   1. F is function of both z and conj(z).
%
%      Method 1: general medium-scale problems.
%      nls_gncgs(F,dF,z0) where F(z) returns a column vector of complex
%      residuals. Set dF equal to the string 'Jacobian-C' for automatic
%      numerical approximation of the complex Jacobian, or supply the
%      complex Jacobian manually with a structure dF containing:
%
%         dF.dzc     - The function dF.dzc(zk) should return the complex
%                      Jacobian [dF(zk)/d(z^T) dF(zk)/d(conj(z)^T)], which
%                      is defined as the matrix in which the m-th row is
%                      equal to [(dFm(zk)/dz); (dFm(zk)/d(conj(z)))]^T,
%                      where Fm is the m-th component of F.
%
%      Method 2: general large-scale problems.
%      nls_gncgs(F,dF,z0) where F(z) returns a column vector of complex
%      residuals and dF is a structure containing:
%
%         dF.dzx     - The function dF.dzx(zk,x,'notransp') should return
%                      the matrix-vector product [dF(zk)/d(z^T)]*x and
%                      dF.dzx(zk,x,'transp') should return the
%                      matrix-vector product [dF(zk)/d(z^T)]'*x.
%         dF.dconjzx - The function dF.dconjzx(zk,x,'notransp') should
%                      return the matrix-vector product
%                      [dF(zk)/d(conj(z)^T)]*x and
%                      dF.dconjzx(zk,x,'transp') should return the matrix-
%                      vector product [dF(zk)/d(conj(z)^T)]'*x.
%
%   2. F is function only of z.
%
%      Method 1: analytic medium-scale problems.
%      nls_gncgs(F,dF,z0) where F(z) returns a column vector of complex
%      residuals. Set dF equal to the string 'Jacobian' for automatic
%      numerical approximation of the Jacobian, respectively. Or, supply
%      the Jacobian manually with a structure dF containing:
%
%         dF.dz      - The function dF.dz(zk) should return the Jacobian
%                      dF(zk)/d(z^T), which is defined as the matrix in
%                      which the m-th row is equal to (dFm(zk)/dz)^T, where
%                      Fm is the m-th component of F.
%
%      Method 2: analytic large-scale problems.
%      nls_gncgs(F,dF,z0) where F(z) returns a column vector of complex
%      residuals and dF is a structure containing:
%
%         dF.dzx     - The function dF.dzx(zk,x,'notransp') should return
%                      the matrix-vector product [dF(zk)/d(z^T)]*x and
%                      dF.dzx(zk,x,'transp') should return the matrix-
%                      vector product [dF(zk)/d(z^T)]'*x.
%
%      Method 3: analytic problems in a modest number of variables z and
%                large number of residuals F(z).
%      nls_gncgs(f,dF,z0) where f(z) := 0.5*(F(z)'*F(z)) and dF is a
%      structure containing:
%
%         dF.JHF     - The function dF.JHF(zk) should return
%                      [dF(zk)/d(z^T)]'*F(zk), which is also equal to
%                      2*df(zk)/d(conj(z)) = 2*conj(df(zk)/d(z)) if z is
%                      complex, or equal to df(xk)/dx if it is real.
%         dF.JHJ     - The function dF.JHF(zk) should return the Gramian
%                      [dF(zk)/d(z^T)]'*[dF(zk)/d(z^T)].
%
%      Method 4: analytic problems in a large number of variables z and
%                large number of residuals F(z).
%      nls_gncgs(f,dF,z0) where f(z) := 0.5*(F(z)'*F(z)) and dF is a
%      structure containing:
%
%         dF.JHF     - The function dF.JHF(zk) should return
%                      [dF(zk)/d(z^T)]'*F(zk), which is also equal to
%                      2*df(zk)/d(conj(z)) = 2*conj(df(zk)/d(z)) if z is
%                      complex, or equal to df(xk)/dx if it is real.
%         dF.JHJx    - The function dF.JHF(zk,x) should return the matrix-
%                      vector product ([dF(zk)/d(z^T)]'*[dF(zk)/d(z^T)])*x.
%
%   The structure output returns additional information:
%
%      output.cgiterations - The number of CG iterations to solve the
%                            trust-region subproblem.
%      output.cgrelres     - The relative residual norm of the computed
%                            Steihaug step.
%      output.delta        - The trust region radius at every step attempt.
%      output.fval         - The value of the objective function f in every
%                            iteration.
%      output.info         - The circumstances under which the procedure
%                            terminated:
%                               1: Objective function tolerance reached.
%                               2: Step size tolerance reached.
%                               3: Maximum number of iterations reached.
%                               4: Absolute objective function tolerance
%                                  reached.
%      output.iterations   - The number of iterations.
%      output.relfval      - The difference in objective function value
%                            between every two successive iterates,
%                            relativeto its initial value.
%      output.relstep      - The step size relative to the norm of the 
%                            current iterate in every iteration.
%      output.rho          - The trustworthiness at every step attempt.
%
%   nls_gncgs(F,dF,z0,options) may be used to set the following options:
%
%      options.CGMaxIter = 15 - The maximum number of CG iterations for
%                               solving the trust-region subproblem.
%      options.CGTol = 1e-6   - The tolerance for the CG method for solving
%                               the trust-region subproblem.
%      options.Delta =        - The initial trust region radius. If equal
%      0.3*max(1,norm(z0))      NaN, the initial radius will be equal to
%                               length of the first Gauss-Newton step.
%      options.Display = 1    - Displays the objective function value, its
%                               difference with the previous iterate
%                               relative to the first iterate and the
%                               relative step size each options.Display
%                               iterations. Set to 0 to disable.
%      options.MaxIter = 200  - The maximum number of iterations.
%      options.TolFun = 1e-12 - The tolerance for output.relfval. Note that
%                               because the objective function is a squared
%                               norm, TolFun can be as small as eps^2.
%      options.TolX = 1e-6    - The tolerance for output.relstep.
%      options.TolAbs = 0     - The tolerance for output.fval.

%   Authors: Laurent Sorber      (Laurent.Sorber@cs.kuleuven.be)
%            Nico Vervliet       (Nico.Vervliet@esat.kuleuven.be)
%            Marc Van Barel      (Marc.VanBarel@cs.kuleuven.be)
%            Lieven De Lathauwer (Lieven.DeLathauwer@kuleuven-kulak.be)
%
%   References:
%   [1] L. Sorber, M. Van Barel, L. De Lathauwer, "Unconstrained
%       optimization of real functions in complex variables", SIAM J. Opt.,
%       Vol. 22, No. 3, 2012, pp. 879-898.
%
% Version History:
% - 2016/02/18    NV    Added absolute tolerance and option parser

% Check the objective function f, derivative dF and first iterate z0.
if ~isa(F,'function_handle')
    error('nls_gncgs:F','The first argument must be a function.');
end
if ischar(dF)
    type = dF;
    if strcmp(type,'Jacobian-C'), fld = 'dzc'; else fld = 'dz'; end
    dF = struct(fld,@derivjac);
end
if ~isstruct(dF)
    error('nls_gncgs:dF','Second argument not valid.');
else
    if isfield(dF,'dzc')
        method = 'F+dFdzc';
    elseif isfield(dF,'dzx') && isfield(dF,'dconjzx')
        method = 'F+dFdzx+dFdconjzx';
    elseif isfield(dF,'dz')
        method = 'F+dFdz';
    elseif isfield(dF,'dzx')
        method = 'F+dFdzx';
    elseif isfield(dF,'JHJ')  && isfield(dF,'JHF')
        method = 'f+JHJ+JHF';
        f = F;
    elseif isfield(dF,'JHJx') && isfield(dF,'JHF')
        method = 'f+JHJx+JHF';
        f = F;
    else
        error('nls_gncgs:dF', ...
             ['The structure dF should supply [dF.dzc] or ' ...
              '[dF.dzx and dF.dconjzx] or [dF.dz] or [dF.dzx] or ' ...
              '[dF.JHJ and dF.JHF] or [dF.JHJx and dF.JHF].']);
    end
end

% Evaluate the function value at z0.
dim = structure(z0);
z = z0;
z0 = serialize(z0);
switch method
    case {'F+dFdzc','F+dFdzx+dFdconjzx','F+dFdz','F+dFdzx'}
        Fval = F(z); Fval = Fval(:);
        fval = 0.5*sum(Fval'*Fval);
    case {'f+JHJ+JHF','f+JHJx+JHF'}
        fval = f(z);
end

% Numerical approximaton of complex derivatives.
function J = derivjac(zk)
    J = deriv(F,zk,Fval,type);
end

% In the case 'F+dFdzx+dFdconjzx', convert J*x and J'*x to the real domain,
% and compute J'*(J*x) in the real domain.
function y = JH_Jx(x)
    x = x(1:end/2)+x(end/2+1:end)*1i;
    dFdzx = dF.dzx(z,x,'notransp');
    dFdconjzconjx = dF.dconjzx(z,conj(x),'notransp');
    y = real(dFdzx)+real(dFdconjzconjx)+ ...
        (imag(dFdzx)+imag(dFdconjzconjx))*1i;
	dFdzx = dF.dzx(z,y,'transp');
    dFdconjzx = dF.dconjzx(z,y,'transp');
    y = [real(dFdzx)+real(dFdconjzx); ...
         imag(dFdzx)-imag(dFdconjzx)];
end

% In the case 'F+dFdzx', compute dFdz'*(dFdz*x).
function y = dFdzH_dFdzx(x)
    y = dF.dzx(z,dF.dzx(z,x,'notransp'),'transp');
end

% In the case 'f+JHJx+JHF', compute JHJ*x.
function y = JHJx(x)
    y = dF.JHJx(z,x);
end

% Modify the preconditioner, if available.
if isfield(dF,'M') && ~isempty(dF.M), dF.PC = @PC; else dF.PC = []; end
function x = PC(b)
    x = dF.M(z,b);
end

% Check the options structure.
p = inputParser;
p.addOptional('CGMaxIter', 15);
p.addOptional('CGTol', 1e-6);
p.addOptional('Delta', 0.3*max(1,norm(z0)));
p.addOptional('Display', 1);
p.addOptional('MaxIter', 200);
p.addOptional('TolFun', 1e-12);
p.addOptional('TolX', 1e-6);
p.addOptional('TolAbs', 0);
p.KeepUnmatched = true;
p.parse(varargin{:});
options = p.Results;

% Gauss-Newton with dogleg trust region.
output.cgiterations = [];
output.cgrelres = [];
output.delta = options.Delta;
output.fval = fval;
output.info = false;
output.iterations = 0;
output.relfval = [];
output.relstep = [];
output.rho = [];
while ~output.info

    % Compute first-order derivatives.
    switch method
        case 'F+dFdzc'
            dFdzc = dF.dzc(z);
            dFdz = dFdzc(:,1:end/2);
            dFdconjz = dFdzc(:,end/2+1:end);
            J = [real(dFdz)+real(dFdconjz),imag(dFdconjz)-imag(dFdz); ...
                 imag(dFdz)+imag(dFdconjz),real(dFdz)-real(dFdconjz)];
            JHJ = J'*J;
            grad = dFdz'*Fval+dFdconjz.'*conj(Fval);
            grad = [real(grad);imag(grad)];
        case 'F+dFdzx+dFdconjzx'
            grad = dF.dzx(z,Fval,'transp')+ ...
                   conj(dF.dconjzx(z,Fval,'transp'));
            grad = [real(grad);imag(grad)];
        case 'F+dFdz'
            dFdz = dF.dz(z);
            JHJ = dFdz'*dFdz;
            grad = dFdz'*Fval;
        case 'F+dFdzx'
            grad = dF.dzx(z,Fval,'transp');
        case 'f+JHJ+JHF'
            grad = serialize(dF.JHF(z));
            JHJ = dF.JHJ(z);
        case 'f+JHJx+JHF'
            grad = serialize(dF.JHF(z));
    end
    
    % CG-Steihaug.
    rho = -inf;
    while rho <= 0

        % Compute the CG-Steihaug step p and estimate objective function
        % improvement.
        delta = output.delta(end);
        switch method
            case 'F+dFdzc'
                [p,~,output.cgrelres(end+1),output.cgiterations(end+1)] ...
                    = pcgsh(JHJ,-grad,delta, ...
                            options.CGTol,options.CGMaxIter,dF.PC);
                p = p(1:end/2)+p(end/2+1:end)*1i;
                grad = grad(1:end/2)+grad(end/2+1:end)*1i;
                dfval = dFdz*p+dFdconjz*conj(p);
                dfval = -real(p'*grad)-0.5*(dfval'*dfval);
                grad = [real(grad);imag(grad)];
            case 'F+dFdzx+dFdconjzx'
                [p,~,output.cgrelres(end+1),output.cgiterations(end+1)] ...
                    = pcgsh(@JH_Jx,-grad,delta, ...
                            options.CGTol,options.CGMaxIter+50,dF.PC);
                p = p(1:end/2)+p(end/2+1:end)*1i;
                grad = grad(1:end/2)+grad(end/2+1:end)*1i;
                dfval = dF.dzx(z,p,'notransp')+ ...
                        dF.dconjzx(z,conj(p),'notransp');
                dfval = -real(p'*grad)-0.5*(dfval'*dfval);
                grad = [real(grad);imag(grad)];
            case 'F+dFdz'
                [p,~,output.cgrelres(end+1),output.cgiterations(end+1)] ...
                    = pcgsh(JHJ,-grad,delta, ...
                            options.CGTol,options.CGMaxIter,dF.PC);
                dfval = dFdz*p;
                dfval = -real(p'*grad)-0.5*(dfval'*dfval);
            case 'F+dFdzx'
                [p,~,output.cgrelres(end+1),output.cgiterations(end+1)] ...
                    = pcgsh(@dFdzH_dFdzx,-grad,delta, ...
                            options.CGTol,options.CGMaxIter,dF.PC);
                dfval = dF.dzx(z,p,'notransp');
                dfval = -real(p'*grad)-0.5*(dfval'*dfval);
            case 'f+JHJ+JHF'
                [p,~,output.cgrelres(end+1),output.cgiterations(end+1)] ...
                    = pcgsh(JHJ,-grad,delta, ...
                            options.CGTol,options.CGMaxIter,dF.PC);
                dfval = -real(p'*grad)-0.5*real(p'*JHJ*p);
            case 'f+JHJx+JHF'
                [p,~,output.cgrelres(end+1),output.cgiterations(end+1)] ...
                    = pcgsh(@JHJx,-grad,delta, ...
                            options.CGTol,options.CGMaxIter,dF.PC);
                dfval = -real(p'*grad)-0.5*real(p'*dF.JHJx(z,p));
        end
        if isnan(output.delta(end))
            delta = max(1,norm(p));
            output.delta(end) = delta;
        end

        % Compute the trustworthiness rho.
        if dfval > 0
            z1 = deserialize(z0+p,dim);
            switch method
                case {'F+dFdzc','F+dFdzx+dFdconjzx','F+dFdz','F+dFdzx'}
                    Fval = F(z1); Fval = Fval(:);
                    fval = 0.5*sum(Fval'*Fval);
                case {'f+JHJ+JHF','f+JHJx+JHF'}
                    fval = f(z1);
            end
            rho = (output.fval(end)-fval)/dfval;
            if isnan(rho), rho = -inf; end
            output.rho(end+1) = rho;
        end

        % Update trust region radius delta.
        if rho > 0.5
            output.delta(end+1) = max(delta,2*norm(p));
        else
            sigma = (1-0.25)/(1+exp(-14*(rho-0.25)))+0.25;
            output.delta(end+1) = sigma*delta;
        end
        
        % Check for convergence.
        relstep = norm(p)/norm(z0); if isnan(relstep), relstep = 0; end
        if rho <= 0 && relstep <= options.TolX
            output.rho(end+1) = rho;
            fval = output.fval(end);
            z = deserialize(z0,dim);
            break;
        end

    end

    % Save current state.
    if rho > 0
        z = z1;
        z0 = z0+p;
    end
    
    % Update the output structure.
    output.fval(end+1) = fval;
    output.iterations = output.iterations+1;
    output.relfval(end+1) = ...
        abs(diff(output.fval(end:-1:end-1)))/abs(output.fval(1));
    output.relstep(end+1) = relstep;
    if output.relfval(end) <= options.TolFun, output.info = 1; end
    if output.relstep(end) <= options.TolX, output.info = 2; end
    if output.iterations >= options.MaxIter, output.info = 3; end
    if output.fval(end) < options.TolAbs, output.info = 4; end
    
    % Display progress.
    if options.Display > 0 && (output.iterations == 1 || output.info || ...
       mod(output.iterations,options.Display) == 0)
        if output.iterations == 1
            bold = '%s';
            [~,~,~,~,v] = regexp(version('-release'),'([0-9]+)([ab])');
            if usejava('Desktop') && str2double(v{1}{1}) > 2011 || ...
               (str2double(v{1}{1}) == 2011 && strcmpi(v{1}{2},'b'))
                bold = '<strong>%s</strong>';
            end
        end
        if output.iterations == 1 || ...
           mod(output.iterations,15*options.Display) == 0
            fprintf('\n%7s%s','',sprintf(bold,'fval'));
            fprintf('%13s%s','',sprintf(bold,'relfval'));
            fprintf('%10s%s','',sprintf(bold,'relstep'));
            fprintf('%10s%s','',sprintf(bold,'delta'));
            fprintf('%8s%s','',sprintf(bold,'rho'));
            fprintf('\n%21s%9s = %4.e %6s = %4.e\n\n','=1/2*norm(F)^2', ...
                    'TolFun',options.TolFun,'TolX',options.TolX);
        end
        if output.iterations == 1
            fprintf('%4i: % 14.8e |\n',0,output.fval(1));
        end
        fprintf('%4i: % 14.8e | %14.8e | %14.8e | %10.4e | %10.4e\n', ...
                output.iterations,output.fval(end), ...
                output.relfval(end),output.relstep(end), ...
                output.delta(end),output.rho(end));
    end

end

% Display termination message.
if options.Display > 0
    ahref = '\n%s\n\n';
    x = round(linspace(0,output.iterations,min(500,output.iterations)));
    if length(bold) > 2
        ahref = sprintf(['\n<a href="matlab:semilogy(%s,%s);' ...
            'xlabel(''iteration'');legend(''fval'',' ...
            '''relfval'',''relstep'')">%%s</a>\n\n'],mat2str(x'), ...
            mat2str([output.fval(x+1)' [nan output.relfval(x(2:end))]' ...
                    [nan output.relstep(x(2:end))]'],3));
    end
    switch output.info
      case 1, fprintf(ahref,'Objective function tolerance reached.');
      case 2, fprintf(ahref,'Step size tolerance reached.');
      case 3, fprintf(ahref,'Maximum number of iterations reached.');
      case 4, fprintf(ahref,'Absolute objective function tolerance reached.');
    end
end

end

function [z,offset] = deserialize(z,dim,offset)
    if iscell(dim)
        v = z;
        z = cell(size(dim));
        if nargin < 3, offset = 0; end
        for i = 1:numel(z)
            if iscell(dim{i})
                [z{i},offset] = deserialize(v,dim{i},offset);
            else
                n = prod(dim{i}(:));
                z{i} = reshape(v(offset+(1:n)),dim{i});
                offset = offset+n;
            end
        end
    elseif ~isempty(dim)
        z = reshape(z,dim);
    end
end

function z = serialize(z)
    if iscell(z)
        for i = find(cellfun(@iscell,z(:).'))
            z{i} = serialize(z{i});
        end
        s = cellfun(@numel,z(:)); o = [0; cumsum(s)];
        c = z; z = zeros(o(end),1);
        for i = 1:length(s), z(o(i)+(1:s(i))) = c{i}(:); end
    else
        z = z(:);
    end
end

function dim = structure(z)
    if iscell(z)
        dim = cellfun(@size,z,'UniformOutput',false);
        for i = find(cellfun(@iscell,z(:).'))
            dim{i} = structure(z{i});
        end
    else
        dim = size(z);
        if numel(z) == dim(1), dim = []; end
    end
end

function [x,flag,relres,iter] = pcgsh(A,b,delta,tol,maxit,M)

% Check the options.
if nargin < 3, delta = nan; end
if nargin < 4 || isempty(tol), tol = 1e-6; end
if nargin < 5 || isempty(maxit), maxit = min(20,length(b)); end
PC = nargin > 5 && (isa(M,'function_handle') || ...
     (isnumeric(M) && all(size(M) == length(b))));

% Initialize PCG-Steihaug.
x = zeros(size(b));
r = -b;
if PC
    if isnumeric(M), y = M\r;
    else y = M(r); end
    d = -y;
    rr = r'*y;
else
    d = -r;
    rr = r'*r;
end
normb = sqrt(rr);
flag = 1;

% PCG-Steihaug.
for iter = 1:maxit

    if isnumeric(A), Ad = A*d;
    else Ad = A(d); end
    alpha = rr/(d'*Ad);

    x1 = x;
    x = x+alpha*d;
    
    % Steihaug's stopping criterion. The case of directions of negative
    % curvature does not need to be handled for NLS.
    if ~isnan(delta) && norm(x) >= delta
        xx = x1'*x1;
        dd = d'*d;
        c = real(x1'*d);
        alpha = (delta^2-xx)/(c+sqrt(c^2+dd*(delta^2-xx)));
        x = x1+alpha*d;
        flag = 2;
    end
    
    r = r+alpha*Ad;
    rr1 = rr;
    if PC
        if isnumeric(M), y = M\r;
        else y = M(r); end
        rr = r'*y;
    else
        rr = r'*r;
    end
    
    if PC, relres = norm(r)/normb;
    else relres = sqrt(rr)/normb; end
    if flag ~= 1, break; end
    if relres < tol, flag = 0; break; end

    beta = rr/rr1;
    if PC, d = -y+beta*d;
    else d = -r+beta*d; end

end

end

##### SOURCE END #####
--></body></html>